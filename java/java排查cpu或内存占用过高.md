1. 使用Top命令查看  
使用大写M可按照内存使用排序，大写P可按cpu使用排序；
---
2. 查看占用过高的程序的线程情况  
top -Hp pid  
这里可以查询到cpu占用较高的线程号，printf '%x\n' 线程号，得到16进制数值的线程号
---
3. 查看内存使用的堆栈信息  
jstack -l pid > pid.log  
这里需要查看下日志详情，特别注意锁、等待。通过2步骤中得到的16进制线程号，可在日志中查看线程状态
---
4. 查看内存对象情况  
jmap -histo:live 6142 |head -20

5. 查看GC情况
jstat -gcutil pid 2000 10
jstat -gcutil 150692 2000 30
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  1.90   0.00   4.63  42.33  74.66  46.14 179920 3842.826  3112  649.187 4492.013
  ......
  1.90   0.00   5.68  42.33  74.66  46.14 179920 3842.826  3112  649.187 4492.013
主要关注：
FGC - Number of full GC events
FGCT - Full garbage collection time
注意：这些值是单调递增的，如果GC频繁，FGC短期存在较大变化（内存不够致高频GC，疑Java内存泄漏，非Java内存不受此监控，如parquet IO直接调用内存），jstack中存在较多高cpu线程进行GC

所以，Java管理的内存泄漏，必然造成cpu高额占用，用于GC；但是相关类库直接操作Java堆外内存，则在java相关诊断工具中无法体现


******************************************************************************************************************************************************************************************

Java 的内存泄漏问题比较难以定位，下面针对一些常见的内存泄漏场景做介绍：

    1.  持续在堆上创建对象而不释放。例如，持续不断的往一个列表中添加对象，而不对列表清空。这种问题，通常可以给程序运行时添加 JVM 参数-Xmx 指定一个较小的运行堆大小，这样可以比较容易的发现这类问题。

    2. 不正 所有的静态变量。

    3.  对大 String 对象调用 String.intern()方法，该方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。而在 jdk6 之前，字符串常量存储在 PermGen 区的，但是默认情况下 PermGen 区比较小，所以较大的字符串调用此方法，很容易会触发内存溢出问题。

    4.  打开的输入流、连接没有争取关闭。由于这些资源需要对应的内存维护状态，因此不关闭会导致这些内存无法释放。
